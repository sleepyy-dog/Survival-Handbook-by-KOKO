# 数学实验与数学软件第二次作业

## 姓名：郑博引 

## 学号：23339147

### 作业：P64 2

![image-20250915163125514](https://sleepy-dog-1376908035.cos.ap-guangzhou.myqcloud.com/202509151631634.png)

自己写的代码，考虑了五种情况（实际四种）：

```matlab
%% Week2a
x_full=[0,1,4,9,16];
x=5;
y=x^(1/2);

for i=4:5
    x0=x_full(1:i);
    y0=x0.^(1/2);
    y1=lagr(x0,y0,x);
    y2=interp1(x0,y0,x);
    y3=spline(x0,y0,x);

    fprintf('使用前 %d 个值计算插值值和误差：\n', i); 
    fprintf('----------------------------------------------------------\n');

    % 以表格形式显示结果
    fprintf('      x      真实值    拉格朗日    线性插值    样条插值\n');
    fprintf('----------------------------------------------------------\n');
    disp([x, y, y1, y2, y3]);

    % 以表格形式显示结果
    fprintf('    拉格朗日误差    线性插值误差    样条插值误差\n');
    fprintf('----------------------------------------------------------\n');
    disp([abs(y1-y)/abs(y), abs(y2-y)/abs(y), abs(y3-y)/abs(y)]);
end

for i=1:3
    x0=x_full(i:5);
    y0=x0.^(1/2);
    y1=lagr(x0,y0,x);
    y2=interp1(x0,y0,x);
    y3=spline(x0,y0,x);

    fprintf('使用后 %d 个值计算插值值和误差：\n', 6-i); 
    fprintf('----------------------------------------------------------\n');

    % 以表格形式显示结果
    fprintf('      x      真实值    拉格朗日    线性插值    样条插值\n');
    fprintf('----------------------------------------------------------\n');
    disp([x, y, y1, y2, y3]);

    % 以表格形式显示结果
    fprintf('    拉格朗日误差    线性插值误差    样条插值误差\n');
    fprintf('----------------------------------------------------------\n');
    disp([abs(y1-y)/abs(y), abs(y2-y)/abs(y), abs(y3-y)/abs(y)]);
end

%% Largrenge func
function y = lagr(x0, y0, x)
n = length(x0);
m = length(x);
for i = 1:m
    z = x(i);
    s = 0;
    for k = 1:n
        p = 1;
        for j = 1:n
            if j ~= k
                p = p * (z - x0(j)) / (x0(k) - x0(j));
            end
        end
        s = p * y0(k) + s;
    end
    y(i) = s;
end
end

```

这样的输出如下

```matlab
使用前 4 个值计算插值值和误差：
----------------------------------------------------------
      x      真实值    拉格朗日    线性插值    样条插值
----------------------------------------------------------
    5.0000    2.2361    2.0000    2.2000    2.0000

    拉格朗日误差    线性插值误差    样条插值误差
----------------------------------------------------------
    0.1056    0.0161    0.1056

使用前 5 个值计算插值值和误差：
----------------------------------------------------------
      x      真实值    拉格朗日    线性插值    样条插值
----------------------------------------------------------
    5.0000    2.2361    2.0794    2.2000    2.1633

    拉格朗日误差    线性插值误差    样条插值误差
----------------------------------------------------------
    0.0701    0.0161    0.0325

使用后 5 个值计算插值值和误差：
----------------------------------------------------------
      x      真实值    拉格朗日    线性插值    样条插值
----------------------------------------------------------
    5.0000    2.2361    2.0794    2.2000    2.1633

    拉格朗日误差    线性插值误差    样条插值误差
----------------------------------------------------------
    0.0701    0.0161    0.0325

使用后 4 个值计算插值值和误差：
----------------------------------------------------------
      x      真实值    拉格朗日    线性插值    样条插值
----------------------------------------------------------
    5.0000    2.2361    2.2540    2.2000    2.2540

    拉格朗日误差    线性插值误差    样条插值误差
----------------------------------------------------------
    0.0080    0.0161    0.0080

使用后 3 个值计算插值值和误差：
----------------------------------------------------------
      x      真实值    拉格朗日    线性插值    样条插值
----------------------------------------------------------
    5.0000    2.2361    2.2190    2.2000    2.2190

    拉格朗日误差    线性插值误差    样条插值误差
----------------------------------------------------------
    0.0076    0.0161    0.0076

>> 
```

但是对于能够完全覆盖点$5$的情况，总共有21种，这样的考虑是不全面的。

而遍历这21种，需要稍微复杂一点的方法，思路是首先对于数组进行分割对于这俩个数组的非空子集进行合并，作为我们选取的所有情况（这里需要保证不会出现外插的情况）。

借助$AI$辅助完成以下代码：

```matlab
%% 解21种情况下的三种插值的所求值和误差估计
clear; clc;

% 对于21种情况下得到的取值和真实值对比，同时对于21种情况统计误差
x_all = [0, 1, 4, 9, 16];
y_all = sqrt(x_all);
x_target = 5;
y_true = sqrt(x_target);

% 输出一下真实值
y_true

% 生成所有节点组合
node_combinations = choose(x_target, x_all);
num_cases = length(node_combinations);

% 预分配空间
NodeSet_str = cell(num_cases, 1);
NumNodes = zeros(num_cases, 1);
Lagrange_Val = zeros(num_cases, 1);
Linear_Val = zeros(num_cases, 1);
CubicSpline_Val = zeros(num_cases, 1);
Lagrange_Err = zeros(num_cases, 1);
Linear_Err = zeros(num_cases, 1);
CubicSpline_Err = zeros(num_cases, 1);

% 循环计算
for i = 1:num_cases
    x0 = node_combinations{i};
    [~, loc] = ismember(x0, x_all);
    y0 = y_all(loc);
    
    % 拉格朗日插值
    y_lagr = lagr(x0, y0, x_target);
    
    % 线性样条插值
    y_linear = interp1(x0, y0, x_target, 'linear');
    
    % 三次样条插值
        y_spline = interp1(x0, y0, x_target, 'spline');
    
    
    % 存储结果
    NodeSet_str{i} = mat2str(x0);
    NumNodes(i) = length(x0);
    Lagrange_Val(i) = y_lagr;
    Linear_Val(i) = y_linear;
    CubicSpline_Val(i) = y_spline;
    Lagrange_Err(i) = abs(y_lagr - y_true)/abs(y_true);
    Linear_Err(i) = abs(y_linear - y_true)/abs(y_true);
    CubicSpline_Err(i) = abs(y_spline - y_true)/abs(y_true);
end

% 创建结果表格
results_table = table(NodeSet_str, NumNodes, ...
                      Lagrange_Val, Lagrange_Err, ...
                      Linear_Val, Linear_Err, ...
                      CubicSpline_Val, CubicSpline_Err);

% 按照节点个数(NumNodes列)从小到大排序
sorted_table = sortrows(results_table, 'NumNodes');

% 显示排序后的表格
disp(sorted_table);


%% function
% 给定数字和一个数字从小到大排列的数组，先将其划分为小于这个数字的数组1和数组2，再在数组1和2中分别选取不少于一个的子集再合并，输出所有这样的选取结果
function combinations = choose(a, A)
    nodes_less = A(A < a);
    nodes_greater = A(A > a);
    
    subsets_less = get_subsets(nodes_less);
    subsets_greater = get_subsets(nodes_greater);
    
    % 对于得到的两个数组，分别调用以下函数，遍历可能的取值个数，从而合并为全部的取值方案。
    combinations = {};
    count = 1;
    for i = 1:length(subsets_less)
        for j = 1:length(subsets_greater)
            combo = sort([subsets_less{i}, subsets_greater{j}]);
            combinations{count} = combo;
            count = count + 1;
        end
    end
end

%% 使用 nchoosek 获取所有非空子集 
function subsets = get_subsets(arr)
    n = length(arr);
    subsets = {}; % 初始化一个空的 cell 数组
    
    % 循环遍历所有可能的子集大小，从 1 到 n
    for k = 1:n
        % 获取所有大小为 k 的组合
        C = nchoosek(arr, k); % C 是一个矩阵，每一行是一个组合
        
        % 将矩阵的每一行转换为一个 cell 元素并追加到结果中
        for i = 1:size(C, 1)
            subsets{end+1} = C(i, :);
        end
    end
end

%% 拉格朗日插值
function y = lagr(x0, y0, x)
    n = length(x0);
    m = length(x);
    y = zeros(1, m);
    for i = 1:m
        z = x(i);
        s = 0;
        for k = 1:n
            p = 1;
            for j = 1:n
                if j ~= k
                    p = p * (z - x0(j)) / (x0(k) - x0(j));
                end
            end
            s = s + p * y0(k);
        end
        y(i) = s;
    end
end

```

对于此代码，输出结果为

```matlab

y_true =

    2.2361

      NodeSet_str       NumNodes    Lagrange_Val    Lagrange_Err    Linear_Val    Linear_Err    CubicSpline_Val    CubicSpline_Err
    ________________    ________    ____________    ____________    __________    __________    _______________    _______________

    {'[0 9]'       }       2           1.6667          0.25464        1.6667        0.25464         1.6667              0.25464   
    {'[0 16]'      }       2             1.25          0.44098          1.25        0.44098           1.25              0.44098   
    {'[1 9]'       }       2                2          0.10557             2        0.10557              2              0.10557   
    {'[1 16]'      }       2              1.8          0.19502           1.8        0.19502            1.8              0.19502   
    {'[4 9]'       }       2              2.2          0.01613           2.2        0.01613            2.2              0.01613   
    {'[4 16]'      }       2           2.1667         0.031037        2.1667       0.031037         2.1667             0.031037   
    {'[0 9 16]'    }       3           1.9048          0.14816        1.6667        0.25464         1.9048              0.14816   
    {'[1 9 16]'    }       3           2.1143         0.054463             2        0.10557         2.1143             0.054463   
    {'[4 9 16]'    }       3            2.219        0.0076117           2.2        0.01613          2.219            0.0076117   
    {'[0 1 9]'     }       3           3.3333          0.49071             2        0.10557         3.3333              0.49071   
    {'[0 1 16]'    }       3                4          0.78885           1.8        0.19502              4              0.78885   
    {'[0 4 9]'     }       3           2.3333         0.043498           2.2        0.01613         2.3333             0.043498   
    {'[0 4 16]'    }       3           2.3958         0.071449        2.1667       0.031037         2.3958             0.071449   
    {'[1 4 9]'     }       3           2.2667         0.013684           2.2        0.01613         2.2667             0.013684   
    {'[1 4 16]'    }       3           2.2889         0.023622        2.1667       0.031037         2.2889             0.023622   
    {'[0 1 9 16]'  }       4           2.9524          0.32034             2        0.10557         2.9524              0.32034   
    {'[0 4 9 16]'  }       4           2.2976         0.027526           2.2        0.01613         2.2976             0.027526   
    {'[1 4 9 16]'  }       4            2.254        0.0080052           2.2        0.01613          2.254            0.0080052   
    {'[0 1 4 9]'   }       4                2          0.10557           2.2        0.01613              2              0.10557   
    {'[0 1 4 16]'  }       4           1.8611          0.16769        2.1667       0.031037         1.8611              0.16769   
    {'[0 1 4 9 16]'}       5           2.0794          0.07008           2.2        0.01613         2.1633             0.032539   
```

观察到对于拉格朗日插值法，我们的输出的误差是飘忽不定的，我们的最优结果是在选取$[4,9,16]$得到的，而我们增加点之后并没有一个显著的提升。而对于线性样条插值，在这道题上并没有明显的误差优势。而三条样条插值则有着和拉格朗日相近的最小误差同时可以注意到选取四个点时，所算的的值和拉格朗日一模一样，这也和计算原理符合的很好。